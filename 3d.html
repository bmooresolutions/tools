### This will allow a user to upload a 3d model file and view it within the web page. HTML5 drag and drop. BMOORESOLUTIONS

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Model Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 20px; }
    #viewer { width: 100%; height: 500px; border: 1px solid #ccc; }
    #dropZone { border: 2px dashed #aaa; padding: 20px; margin-top: 10px; text-align: center; }
    #loading { display: none; font-weight: bold; margin-top: 10px; }
    #modelInfo { margin-top: 10px; }
    .annotation { position: absolute; background: rgba(255,255,255,0.8); padding: 4px; border-radius: 4px; pointer-events: none; }
  </style>
</head>
<body>
  <h1>Upload and View Your 3D Model</h1>
  <input type="file" id="modelUpload" accept=".glb,.gltf,.obj,.fbx" />
  <input type="file" id="textureUpload" accept="image/*" />
  <div id="dropZone">Drag and drop your model here</div>
  <div id="loading">Loading model...</div>
  <div id="modelInfo"></div>
  <div id="viewer"></div>

  <!-- Three.js and loaders -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/loaders/FBXLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    const viewer = document.getElementById('viewer');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(75, viewer.clientWidth / viewer.clientHeight, 0.1, 1000);
    camera.position.set(0, 1, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    viewer.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
    scene.add(ambientLight, hemiLight);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    function loadModel(file) {
      const url = URL.createObjectURL(file);
      const ext = file.name.split('.').pop().toLowerCase();
      document.getElementById('loading').style.display = 'block';

      scene.clear();
      scene.add(ambientLight, hemiLight);

      const showInfo = (obj) => {
        const info = `
          <strong>File:</strong> ${file.name}<br>
          <strong>Size:</strong> ${(file.size / 1024).toFixed(2)} KB<br>
          <strong>Format:</strong> ${ext}<br>
          <strong>Meshes:</strong> ${obj.children.length}
        `;
        document.getElementById('modelInfo').innerHTML = info;
        document.getElementById('loading').style.display = 'none';
      };

      if (ext === 'glb' || ext === 'gltf') {
        const loader = new THREE.GLTFLoader();
        loader.load(url, gltf => {
          scene.add(gltf.scene);
          showInfo(gltf.scene);
        });
      } else if (ext === 'obj') {
        const loader = new THREE.OBJLoader();
        loader.load(url, obj => {
          scene.add(obj);
          showInfo(obj);
        });
      } else if (ext === 'fbx') {
        const loader = new THREE.FBXLoader();
        loader.load(url, obj => {
          scene.add(obj);
          showInfo(obj);
        });
      }
    }

    document.getElementById('modelUpload').addEventListener('change', e => {
      const file = e.target.files[0];
      if (file) loadModel(file);
    });

    document.getElementById('dropZone').addEventListener('dragover', e => e.preventDefault());
    document.getElementById('dropZone').addEventListener('drop', e => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      if (file) loadModel(file);
    });

    document.getElementById('textureUpload').addEventListener('change', e => {
      const textureFile = e.target.files[0];
      if (textureFile) {
        const textureURL = URL.createObjectURL(textureFile);
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(textureURL, texture => {
          scene.traverse(child => {
            if (child.isMesh) {
              child.material.map = texture;
              child.material.needsUpdate = true;
            }
          });
        });
      }
    });

    renderer.domElement.addEventListener('click', e => {
      mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
      mouse.y = -(e.clientY / renderer.domElement.clientHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      if (intersects.length > 0) {
        const label = document.createElement('div');
        label.className = 'annotation';
        label.style.left = `${e.clientX}px`;
        label.style.top = `${e.clientY}px`;
        label.textContent = 'Annotation';
        document.body.appendChild(label);
      }
    });
  </script>
</body>
</html>
